
DETECT A CYCLE IN A GRAPH 
 bool detect(int n,int vis[],vector<int>adj[])
    {
        vis[n]=1;
        queue<pair<int,int>> q;
        q.push({n,-1});
        while(!q.empty())
        {
            int parent=q.front().second;//here front is the function so () should thhere for it 
            int node=q.front().first;//not for first or second
            q.pop();
            for(auto adjnode:adj[node])
            {
                if(!vis[adjnode])
            {
                vis[adjnode]=1;
                q.push({adjnode,node});//at this point node becomes the parent i.e q.seocnd
                //and adjnode becomes the node or child sp this step is written 
            }
            else if(parent!=adjnode)    return true;
            }
        }
        return false;
    }
    bool isCycle(int V, vector<int> adj[]) {
        int vis[V]={0};
        for(int i=0;i<V;i++)
        {
            if(!vis[i])  
            {  
                if(detect(i,vis,adj))//noneed of [] beside adj or vis
                    return true;
            }
        }
        return false;
    }
BFS OF A GRAPH:
clear intuition: 

vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        // Code here visited array,queue,insert into queue look if its visited then skip 
        vector<int> visited;//lets say this is the vector for bfs traversal
        int visit[V]={0};
        visit[0]=1;
        queue<int> q;
        q.push(0);
        while(!q.empty())
        {
            int g=q.front();//here g signifies the node 
            q.pop();
            visited.push_back(g);
        for(auto it:adj[g])
        {if(!visit[it])
        {
            visit[it]=1;
            q.push(it);
        }} }
        return visited;
    }

DFS INORDER TRAVERSAL:
LEETCODE DAIly challenge:
Its my first solution which i have done on my own i feel very proud though it has a TC OF o(n2) I STILL feel proud about this 
INTUITION:
FIRSTLY INSERT THE ELEMENTS IN INORDER TRAVERSAL INTO THE VECTOR AND COMPUTE THE MINIMUM ABSOLUTE DIFFERENCE 
class Solution {
public:
   vector<int>mindif;
    void dfsinorder(TreeNode* node)
    {
        if(node==NULL)
        return;
        dfsinorder(node->left);
        mindif.push_back(node->val);
        dfsinorder(node->right);
    }
    int getMinimumDifference(TreeNode* root) {
        if(root==NULL)
        return 0;
        dfsinorder(root);
        int x=INT_MAX;
        for(int i=0;i<mindif.size();i++)
        {
            {
                for(int j=i+1;j<mindif.size();j++)
                {
                    int diff=abs(mindif[i]-mindif[j]);
                    x=min(x,diff);
                }
            }
           
        }
        return x;

    }
};
