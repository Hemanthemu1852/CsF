Binary tree representation:
u r given a vector and its root node and u have to create a tree 
USING RECURSION 
node* build(vector<int> &v, int i) {
        node *root = NULL;
        if(i < v.size()) {
            root = newNode(v[i]);
        }
        else
            return NULL;
        i = 2*i;
        root->left = build(v, i+1);
        root->right = build(v, i+2);
        return root;
    }
    void create_tree(node* &root0, vector<int> &vec){
        //Your code goes here
        root0 = build(vec, 0);
    }

USING QUEUE:
void create_tree(node* root0, vector<int> &vec){
        queue<node*> q;
        q.push(root0); 
        int i=1;/*declaraction*/ 
        int n=vec.size();
        while(i<n) // condition
        {
            //here node changes 
            node *rn=q.front();
            q.pop();
            node* left=newNode(vec[i++]);//updation
            rn->left=left;
            q.push(left);
            if(i>=n) break;
            node* right=newNode(vec[i++]);//2nd updation 
            rn->right=right;
            q.push(right);
        }
    }
